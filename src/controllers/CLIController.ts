/**
 * @fileoverview CLI Controller bridge component
 * Controller for managing secrets in MongoDB through CLI interactions using SecretManagerMDB.
 * Supports operations like saving and resolving secrets using encryption.
 *
 * @author IaC Pipeline Team
 * @since 1.0.0
 * @version 1.1.0
 */

import * as fs from 'fs';
import { ILoggerService } from '../models/Logger';
import { IConfig } from '../models/Pipeline';
import { ICLIArgs, VCategory } from '../models/Types';
import { getID, IIoC, ILogInput, ILogLevel, IoC } from '../tools';

export class CLIController {
    /**
     * IoC container instance for dependency injection and service resolution
     * @type {IIoC | null}
     */
    protected assistant?: IIoC | null;

    protected args: any;

    public get helper() {
        return this.assistant;
    }

    public getArgs<T = ICLIArgs>(): T {
        return this.args as T;
    }

    /**
     * Logger service instance for recording secret management operations
     * @type {ILoggerService | null}
     */
    public logger?: ILoggerService | null;

    /**
     * Creates a new CLIController instance
     *
     * @constructor
     * @param {ISecretManagerOptions} [options] - Configuration options for MongoDB and encryption
     */
    constructor(dependency?: { assistant: IIoC, logger: ILoggerService }) {
        this.assistant = dependency?.assistant ?? new IoC();
        this.logger = dependency?.logger ?? null;
    }

    /**
     * Displays CLI usage information for working with secrets
     * @public
     * @static
     */
    public help(): void {
        console.log(`
===============================================================================
Kozen Engine Tool
===============================================================================

Usage:
    kozen --action=<value> [--controller=<value>]

Options:
    --stack=<id>                    Environment identifier (optional) (default: autogenerated, e.g., 'dev')
    --project=<id>                  Project identifier (optional) (default: autogenerated, e.g., 'K2025071525')
    --config=<file>                 Configuration file path (optional) (default: cfg/config.json)
    --controller=logger             Set controller name (required if not specified in the action). The possible values are:
                                    - pipeline: Tool to manage automated pipelines
                                    - logger: Tool to manage system logs
                                    - secret: Tool to manage secrets through an external or remote Secret Manager
    --action=<[controller:]action>  Action to be performed within the Logger Manager tool. The possible values are:
                                    - help: Get help or assistance on how to use a tool

Environment Variables:
    KOZEN_CONFIG               Default value assigned to the --config property
    KOZEN_ACTION               Default value assigned to the --action property
    KOZEN_STACK                Default value assigned to the --stack property
    KOZEN_PROJECT              Default value assigned to the --project property

Examples:
    kozen --action=help --controller=pipeline
    kozen --action=pipeline:help
===============================================================================
        `);
    }

    /**
     * Loads pipeline configuration from a JSON file
     * @public
     * @param {string} configPath - File system path to the configuration file
     * @returns {Promise<IConfig>} Promise resolving to the loaded and parsed pipeline configuration
     * @throws {Error} When file reading fails, JSON parsing errors occur, or file access is denied
     * 
     * Loads and parses pipeline configuration from a JSON file, providing error handling
     * for common file system and parsing issues. The configuration includes service dependencies,
     * deployment settings, and environment-specific parameters.
     */
    public async load(configPath: string): Promise<IConfig> {
        try {
            const configContent = fs.readFileSync(configPath, 'utf8');
            const config = JSON.parse(configContent) as IConfig;
            // config.id = this.getId(arg);
            config.name = config.name || 'Default';
            config.engine = config.engine || 'default';
            config.version = config.version || '1.0.0';
            config.description = config.description || 'Kozen Engine Default Configuration';
            return config;
        } catch (error) {
            throw new Error(`Failed to load configuration: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Get Pipeline ID
     * @param {IConfig} opt 
     * @returns {string}
     */
    public getId(opt?: IConfig) {
        return opt?.id || `${opt?.project ?? ''}-${opt?.stack ?? ''}`;
    }

    /**
     * Configures the secret controller with provided arguments and dependencies
     * @public
     * @param {ICLIArgs} args - Secret controller configuration arguments
     * @returns {Promise<void>} Promise that resolves when configuration is complete
     * @throws {Error} When configuration fails due to invalid configuration or dependency registration errors
     * 
     * This method sets up the secret controller by:
     * 1. Loading the configuration file if provided
     * 2. Setting up the IoC container for dependency injection
     * 3. Registering all service dependencies defined in the configuration
     */
    public async configure(args: ICLIArgs): Promise<IConfig | null> {
        try {
            const config = args.config && await this.load(args.config);
            if (!config) {
                return null;
            }
            if (!this.assistant) {
                throw new Error("Incorrect dependency injection configuration.");
            }
            config.dependencies && await this.assistant.register(config.dependencies);
            this.logger = this.logger || await this.assistant.resolve<ILoggerService>('LoggerService');
            return config;
        } catch (error) {
            throw new Error(`Failed to configure: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    public async init<T = ICLIArgs>(argv?: string[] | ICLIArgs): Promise<{ args?: T, config?: IConfig | null }> {
        const args = await this.fillout(argv ?? process.argv);
        const config = await this.configure(args);
        this.args = args;
        return { args: args as T, config };
    }

    /**
     * Parses command line arguments into structured format
     * @public
     * @param {string[]} args - Command line arguments array
     * @returns {ICLIArgs} Parsed CLI arguments with defaults applied
     */
    public async fillout(args: string[] | ICLIArgs): Promise<ICLIArgs> {
        let parsed: Partial<ICLIArgs> = this.extract(args);
        parsed.action = parsed.action || process.env['KOZEN_ACTION'] || 'deploy';
        let option = parsed.action?.split(":") || [];
        parsed.stack = (parsed.stack || process.env.KOZEN_STACK || process.env["NODE_ENV"] || 'dev').toUpperCase();
        parsed.project = parsed.project || process.env.KOZEN_PROJECT || getID();
        parsed.action = option?.length > 1 ? option[1] : option[0];
        parsed.controller = this.capitalizeFirstLetter(option?.length > 1 ? option[0] : (parsed.controller || process.env['KOZEN_CONTROLLER'] || '')) + 'Controller';
        parsed.config = parsed.config || process.env.KOZEN_CONFIG || 'cfg/config.json';
        return parsed as ICLIArgs;
    }

    /**
     * Extracts key-value pairs from command line arguments array
     * @public
     * @param {string[]} [argv] - Command line arguments array, defaults to process.argv
     * @returns {Record<string, string>} Object containing parsed argument key-value pairs
     */
    protected extract(argv?: string[] | ICLIArgs): Record<string, any> {
        if (!Array.isArray(argv) && typeof argv === 'object') {
            return argv;
        }
        argv = argv || process.argv;
        return argv.slice(2).reduce((acc: Record<string, string>, arg: string) => {
            const [key, value] = arg.split('=');
            acc[key.replace('--', '')] = value;
            return acc;
        }, {});
    }

    /**
     * Waits for all pending logger operations to complete
     * @public
     * @returns {Promise<void>} Promise that resolves when all log operations complete
     */
    public async wait(): Promise<void> {
        if (this.logger?.stack) {
            await Promise.all(this.logger.stack)
        }
    }

    /**
     * Logs a message using the pipeline logger with specified level
     * @public
     * @param {ILogInput} input - Log input message or structured log object
     * @param {ILogLevel} [level] - Log level, defaults to INFO
     * @returns {void | Promise<void>} Log operation result
     */
    public async log(input: ILogInput, level: ILogLevel = ILogLevel.INFO) {
        if (typeof input === 'object') {
            input.category = input.category || VCategory.cli.tool;
            input.flow = input.flow || this.getId(input as unknown as IConfig);
        }
        this.logger?.log(input, level);
    }

    /**
     * Capitalize First Letter
     * @param {string} str
     * @returns {string}
     */
    protected capitalizeFirstLetter(str: string): string {
        return str ? str[0].toUpperCase() + str.slice(1) : '';
    }
}
